/*
 * Takí Project
 *
 * IF683 Takí project
 *
 * API version: 1.0.0
 * Contact: mvgmb@cin.ufpe.br
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package server

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
)

type StoreMap struct {
	Map [][]interface{} `json:"map"`
}

func StoreStoreIDListListIDDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// TODO get
func StoreStoreIdListListIdGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	// Dummy test, shows how to use gorilla/mux
	vars := mux.Vars(r)
	log.Println(vars["storeId"])
	log.Println(vars["listId"])
}

func StoreStoreIdListListIdPut(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func StoreStoreIdListListIdRouteGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func StoreStoreIdListNewPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// TODO get
func StoreStoreIdListsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// StoreStoreIdMapGet return the Map of a given Store
func StoreStoreIdMapGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	vars := mux.Vars(r)

	stmt := fmt.Sprintf(`
	SELECT map
	FROM stores 
	WHERE _id = %s`, vars["storeId"])

	rows, err := db.Query(stmt)
	if err != nil {
		log.Fatal(err)
	}

	var mapString string

	if rows.Next() {
		err = rows.Scan(&mapString)
		if err != nil {
			log.Fatal(err)
		}
	}

	raw := StoreMap{}

	err = json.Unmarshal([]byte(mapString), &raw)
	if err != nil {
		log.Println(err)
	}

	var storeMap ModelMap
	var mapValue MapValue

	for i := range raw.Map {
		var row []MapValue
		for j := range raw.Map[i] {
			slot := raw.Map[i][j].([]interface{})

			aisle, err := strconv.Atoi(slot[1].(string))
			if err != nil {
				log.Fatal(err)
			}

			direction, err := strconv.Atoi(slot[2].(string))
			if err != nil {
				log.Fatal(err)
			}

			mapValue.Category = slot[0].(string)
			mapValue.Aisle = int32(aisle)
			mapValue.Direction = int32(direction)

			row = append(row, mapValue)
		}
		storeMap.Matrix = append(storeMap.Matrix, row)
	}

	bytes, err := json.Marshal(storeMap)
	if err != nil {
		log.Fatal(err)
	}
	w.Write(bytes)
}

// StoreStoreIdProductsGet returns all Products of a given Store
func StoreStoreIdProductsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	_, err := checkAuthentication(r)
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		log.Println(err)
		return
	}

	vars := mux.Vars(r)

	stmt := fmt.Sprintf(`
	SELECT p._id, p.name, p.description 
	FROM products AS p, product_category AS pc 
	WHERE p._id = pc.product_id AND pc.store_id = %s`, vars["storeId"])

	rows, err := db.Query(stmt)
	if err != nil {
		log.Fatal(err)
	}

	var products []Product
	var p Product

	for rows.Next() {
		err = rows.Scan(&p.Id, &p.Name, &p.Description)
		if err != nil {
			log.Fatal(err)
		}
		products = append(products, p)
	}

	bytes, err := json.Marshal(products)
	if err != nil {
		log.Fatal(err)
	}
	w.WriteHeader(http.StatusOK)
	w.Write(bytes)
}

// TODO get
func StoresGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// TODO get
func UserGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// UserNewPost registers a new User
func UserNewPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

	user, err := parseUser(r)
	if err != nil {
		log.Fatal(err)
	}

	stmt := fmt.Sprintf(`
	INSERT INTO users (name, email, birthday, sex, permission) 
	VALUES ('%s', '%s', '%s', %d, '%s')`, user.Name, user.Email, user.Birthday, user.Sex, user.Permission)

	_, err = db.Query(stmt)
	if err != nil {
		log.Fatal(err)
	}
}
